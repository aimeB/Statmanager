import { Component, OnInit, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { ActivatedRoute } from '@angular/router';
import { TerrainService } from '../../../services/terrain.service';
import { FeuilleDeMatchDTO } from '../../../../feuille-de-match/models/feuille-de-match.model';
import { TerrainDTO } from '../../../models/terrain.model';
import { MatDialog } from '@angular/material/dialog';
import { ChangeDetectorRef } from '@angular/core';
import { Client } from '@stomp/stompjs';
import SockJS from 'sockjs-client';
import { JoueurSelectionDialogComponent } from '../../../../joueur/components/joueur-selection-dialog/joueur-selection-dialog.component';
import { MatChipsModule } from '@angular/material/chips';
import { MatIconModule } from '@angular/material/icon';
import { MatCardModule } from '@angular/material/card';
import { RouterModule } from '@angular/router';
import { EvenementMatchDTO, RemplacementDTO } from '../../../models/rencontre.model';
import { TimePlay, fromPercentage, getTimePlayLabel, } from '../../../../../shared/models/time-play.enum';
import {CoteAttributionDialogComponent } from '../../../../../shared/components/cote/cote-attribution-dialog.component';
import {ClotureRencontreDTO} from '../../../../../modules/rencontre/models/rencontre.model';
import { Division } from '../../../../../shared/models/division.enum';



@Component({
  selector: 'app-detail-terrain',
  standalone: true,
  schemas: [CUSTOM_ELEMENTS_SCHEMA],
  imports: [
    CommonModule,
    FormsModule,
    MatChipsModule,
    MatIconModule,
    RouterModule,
    MatCardModule,

  ],
  templateUrl: './detail-terrain.component.html',
  styleUrls: ['./detail-terrain.component.scss'],
})

export class DetailTerrainComponent implements OnInit {

  butEquipe: number = 0;
  butAdversaire: number = 0;
  joueurSelectionne: FeuilleDeMatchDTO | null = null;
  passeursDisponibles: FeuilleDeMatchDTO[] = [];
  joueurEntrant: FeuilleDeMatchDTO | null = null;
  joueurSortant: FeuilleDeMatchDTO | null = null;
  minuteRemplacement: number | null = null;
  private stompClient!: Client;
  butsMarques: EvenementMatchDTO[] = [];
  timePlayValues = Object.values(TimePlay).filter(v => typeof v === "number") as number[];

  getTimePlayLabel(value: number): string {
    return getTimePlayLabel(value as TimePlay);
  }
  



  // ‚úÖ Propri√©t√©s de terrain
  terrain: TerrainDTO = {} as TerrainDTO;


  constructor(
    private route: ActivatedRoute,
    private terrainService: TerrainService,
    private dialog: MatDialog,
    private cdr: ChangeDetectorRef
  ) {}





  ngOnInit(): void {
    const idRencontre = Number(this.route.snapshot.paramMap.get('idRencontre'));
  
    if (!idRencontre) {
      console.error('‚ùå ID de rencontre manquant.');
      return;
    }
  
    // ‚úÖ R√©cup√©ration du terrain
    this.terrainService.getTerrain(idRencontre).subscribe({
      next: (terrainData) => {
        console.log("üì• [Front] Terrain re√ßu depuis backend :", terrainData);
        this.terrain = this.mapperTerrainDTO(terrainData);
        this.cdr.detectChanges();
      },
      error: (err) => {
        console.error("‚ùå Erreur lors de la r√©cup√©ration du terrain :", err);
      }
    });
  
    // ‚úÖ R√©cup√©ration de l‚Äôhistorique des √©v√©nements (buts + remplacements)
    this.terrainService.getHistoriqueEvenements(idRencontre).subscribe({
      next: (historique) => {
        console.log("üì• Historique des √©v√©nements re√ßu :", historique);
        this.butsMarques = historique;
        this.cdr.detectChanges();
      },
      error: (err) => {
        console.error("‚ùå Erreur lors de la r√©cup√©ration de l'historique des √©v√©nements :", err);
      }
    });
  
    this.initialiserWebSocket();
  }
  










  private initialiserWebSocket(): void {


    this.stompClient.subscribe('/topic/stats', (message) => {
      const update = JSON.parse(message.body);
      console.log('üîÑ Mise √† jour des stats re√ßue via WebSocket:', update);
      this.actualiserStats(update);
    });
    
    this.stompClient.subscribe('/topic/remplacements', (message) => {
      const update = JSON.parse(message.body);
      console.log('üîÑ Remplacement re√ßu via WebSocket:', update);
      this.actualiserRemplacement(update);
    });
  

    this.stompClient = new Client({
      brokerURL: undefined,
      webSocketFactory: () => new SockJS('http://localhost:8080/ws'),
      reconnectDelay: 5000,
      heartbeatIncoming: 4000,
      heartbeatOutgoing: 4000,
      debug: (str) => console.log('STOMP Debug:', str)
    });

    this.stompClient.onConnect = () => {
      console.log('üü¢ WebSocket STOMP connect√©');
      this.stompClient.subscribe('/topic/remplacements', (message) => {
        const update = JSON.parse(message.body);
        console.log('üîÑ Remplacement re√ßu via WebSocket:', update);
        this.actualiserRemplacement(update);
      });

      this.stompClient.subscribe('/topic/stats', (message) => {
        const update = JSON.parse(message.body);
        console.log('üîÑ Mise √† jour des stats re√ßue via WebSocket:', update);
        this.actualiserStats(update);
      });
    };

    this.stompClient.onStompError = (frame) => {
      console.error('‚ùå Erreur STOMP :', frame);
    };

    this.stompClient.activate();
  }

  private mapperTerrainDTO(terrainData: any): TerrainDTO {
    return { ...terrainData } as TerrainDTO;
}




mettreAJourButAdversaire(nouveauScore: number): void {
  this.butAdversaire = nouveauScore;
  this.terrain.butAdversaire = nouveauScore; // ‚úÖ Mise √† jour du terrain
  this.terrain.titulaires.forEach(joueur => {
    if (joueur.poste === "GB") {
      joueur.butEncaisser = nouveauScore; // ‚úÖ Mise √† jour automatique du gardien
    }
  });

  console.log(`üîÑ Score de l‚Äôadversaire mis √† jour : ${this.butAdversaire}`);
  this.cdr.detectChanges();
}



ajouterArretGardien(): void {
  const gardien = this.terrain.titulaires.find(j => j.poste === "GB");
  if (gardien) {
    gardien.butArreter = (gardien.butArreter || 0) + 1;
    console.log(`üß§ Sauvetage ajout√© pour ${gardien.nom} : ${gardien.butArreter}`);
    this.cdr.detectChanges();
  }
}








  actualiserStats(update: any): void {
    if (!this.terrain) {
      console.error("‚ùå Erreur : Le terrain n'est pas initialis√©.");
      return;
    }

    const { idJoueur, buts, idPasseur, butEquipe, butAdversaire } = update;

    // ‚úÖ Mettre √† jour les buts et passes des joueurs
    Object.keys(this.terrain.terrainJoueurs).forEach(poste => {
      if (this.terrain.terrainJoueurs[poste]?.jid === idJoueur) {
        this.terrain.terrainJoueurs[poste].buts = buts;
      }
      if (idPasseur && this.terrain.terrainJoueurs[poste]?.jid === idPasseur) {
        this.terrain.terrainJoueurs[poste].passes = (this.terrain.terrainJoueurs[poste].passes || 0) + 1;
      }
    });

    // ‚úÖ Mise √† jour du score global
    this.butEquipe = butEquipe;
    this.butAdversaire = butAdversaire;

    this.cdr.detectChanges();
  }





  actualiserRemplacement(update: any): void {
    const { idRemplacant, idSortant } = update;

    const remplacant = this.terrain.remplacants.find(j => j.jid === idRemplacant);
    const sortant = this.terrain.titulaires.find(j => j.jid === idSortant);

    if (!remplacant || !sortant) {
      console.warn("‚ö†Ô∏è Remplacement impossible : joueur non trouv√©", { remplacant, sortant });
      return;
    }

    // ‚úÖ Mise √† jour des listes titulaires/rempla√ßants
    this.terrain.titulaires = this.terrain.titulaires.filter(j => j.jid !== sortant.jid);
    this.terrain.remplacants.push(sortant);

    this.terrain.remplacants = this.terrain.remplacants.filter(j => j.jid !== remplacant.jid);
    this.terrain.titulaires.push(remplacant);

    // ‚úÖ Mise √† jour du terrain
    Object.keys(this.terrain.terrainJoueurs).forEach(poste => {
      if (this.terrain.terrainJoueurs[poste]?.jid === sortant.jid) {
        this.terrain.terrainJoueurs[poste] = remplacant;
      }
    });

    console.log("üîÑ Mise √† jour du terrain apr√®s remplacement:", this.terrain.terrainJoueurs);
    this.cdr.detectChanges();
  }






  

  ouvrirPopupCotes(): void {
    const joueursAvecCotes = [...this.terrain.titulaires, ...this.terrain.remplacants]
      .filter(joueur => joueur.titulaire || joueur.aJoue) // ‚úÖ Seuls les joueurs ayant jou√©
  
    const dialogRef = this.dialog.open(CoteAttributionDialogComponent, {
      data: { joueurs: joueursAvecCotes }
    });
  
    dialogRef.afterClosed().subscribe((result) => {
      if (result) {
        console.log("‚úÖ Cotes mises √† jour :", result);
        this.cloturerRencontre(result);
      }
    });
  }
  




  incrementerBut(joueur: FeuilleDeMatchDTO): void {
    if (!joueur || !joueur.jid) {
      console.error("‚ùå Erreur : Joueur invalide !");
      return;
    }
  
    // ‚úÖ V√©rifier si terrain.butsModifies existe et mettre √† jour
    if (!this.terrain.butsModifies) {
      this.terrain.butsModifies = {};
    }
  
    // ‚úÖ Incr√©menter le nombre de buts du joueur
    this.terrain.butsModifies[joueur.jid] = (this.terrain.butsModifies[joueur.jid] || 0) + 1;
  
    console.log(`‚öΩ But ajout√© pour ${joueur.nom} (Total : ${this.terrain.butsModifies[joueur.jid]})`);
  
    this.joueurSelectionne = joueur; // ‚úÖ D√©finit le joueur ayant marqu√© comme s√©lectionn√©
  
    this.cdr.detectChanges();
  
    // ‚úÖ Ouvre imm√©diatement la fen√™tre de s√©lection du passeur
    this.selectionnerPasseur();
  }
  
  










  getJoueursDisponiblesPourPasse(buteurFeuilleId: number): FeuilleDeMatchDTO[] {
    return Object.values(this.terrain.terrainJoueurs).filter(joueur => joueur.id !== buteurFeuilleId);
  }






  cloturerRencontre(cotes: Record<number, number>): void {
    if (!this.terrain) {
      console.error('‚ùå Erreur: Terrain non disponible.');
      return;
    }
  
    if (this.butAdversaire === 0) {
      alert('‚ö†Ô∏è Vous devez entrer le score de l\'adversaire avant de cl√¥turer.');
      return;
    }
  
    const clotureDTO: ClotureRencontreDTO = {
      idRencontre: this.terrain.idRencontre,
      nomAdversaire: this.terrain.nomAdversaire, // ‚úÖ Correction
      butAdversaire: this.butAdversaire,
      divisionAdversaire: this.terrain.divisionAdversaire as Division, // ‚úÖ Conversion explicite

      cotes: cotes,
      butsArretes: this.terrain.titulaires
        .filter(j => j.poste === "GB" && j.butArreter !== undefined) // ‚úÖ Filtrer uniquement les gardiens
        .reduce((acc, gardien) => {
          acc[gardien.jid] = gardien.butArreter || 0;
          return acc;
        }, {} as Record<number, number>), // ‚úÖ Conversion en `Record<number, number>`
    };
  
    console.log("üèÜ Envoi des donn√©es de cl√¥ture :", clotureDTO);
  
    this.terrainService.cloturerRencontre(this.terrain.idRencontre, clotureDTO).subscribe({ // ‚úÖ Ajout de `idRencontre`
      next: () => {
        alert("üèÜ Rencontre cl√¥tur√©e !");
      },
      error: (err) => {
        console.error("‚ùå Erreur lors de la cl√¥ture de la rencontre :", err);
      }
    });
  }
  
  







  selectionnerPasseur(): void {
    if (!this.joueurSelectionne) {
      console.error("‚ùå Aucun joueur s√©lectionn√© pour le but.");
      return;
    }
  
    // ‚úÖ Exclure le buteur des joueurs pouvant √™tre passeurs
    const joueursProposables: FeuilleDeMatchDTO[] = Object.values(this.terrain.terrainJoueurs)
      .filter(joueur => joueur.jid !== this.joueurSelectionne!.jid);
  
    if (joueursProposables.length === 0) {
      alert("‚ùå Aucun joueur disponible pour faire une passe !");
      return;
    }
  
    // ‚úÖ Ouvrir la bo√Æte de dialogue avec `FeuilleDeMatchDTO`
    const dialogRef = this.dialog.open(JoueurSelectionDialogComponent, {
      data: { joueurs: joueursProposables, type: 'FeuilleDeMatchDTO' }, // ‚úÖ Indiquer le type
      width: '400px'
    });
  
    dialogRef.afterClosed().subscribe((passeurSelectionne: FeuilleDeMatchDTO) => {
      if (passeurSelectionne) {
        console.log(`üéØ Passeur s√©lectionn√© : ${passeurSelectionne.nom}`);
        this.envoyerButEtPasseur(passeurSelectionne);
      } else {
        console.log("‚ùå Aucun passeur s√©lectionn√©");
      }
    });
  }
  




  envoyerButEtPasseur(passeur: FeuilleDeMatchDTO): void {
    if (!this.joueurSelectionne) {
      console.error("‚ùå Aucun joueur s√©lectionn√© pour l'envoi du but.");
      return;
    }
  
    this.terrainService.updateStatsEnTempsReel(
      this.terrain.idRencontre,
      this.joueurSelectionne.jid, // ‚úÖ ID du buteur
      (this.terrain.butsModifies[this.joueurSelectionne.jid] || 0) + 1, // ‚úÖ Incr√©mente les buts
      passeur.jid // ‚úÖ ID du passeur
    ).subscribe({
      next: (terrainDTO) => {
        console.log("‚úÖ But et passe mis √† jour avec succ√®s :", terrainDTO);
        this.terrain = terrainDTO;
        this.cdr.detectChanges();
      },
      error: (err) => {
        console.error("‚ùå Erreur lors de l'enregistrement du but :", err);
      }
    });
  }
  







  effectuerRemplacement(): void {
    if (!this.joueurSortant || !this.joueurEntrant || this.minuteRemplacement === null) {
      alert("‚ùå Veuillez s√©lectionner un titulaire, un rempla√ßant et une minute !");
      return;
    }
  
    console.log(`üîÑ Tentative de remplacement : ${this.joueurSortant.nom} ‚û° ${this.joueurEntrant.nom} √† ${this.minuteRemplacement * 90} min`);
  
    // ‚úÖ Conversion de la minute en TimePlay
    const minuteEntree = fromPercentage(this.minuteRemplacement);

  
    const remplacementDTO: RemplacementDTO = {
      idRencontre: this.terrain.idRencontre,
      idRemplacantEntrant: this.joueurEntrant.jid,
      idTitulaireSortant: this.joueurSortant.jid,
      minuteEntree: minuteEntree 
    };
  
    console.log("üîÑ Envoi du remplacement :", remplacementDTO);
  
    this.terrainService.effectuerRemplacement(this.terrain.idRencontre, remplacementDTO).subscribe({
      next: (terrainDTO) => {
        if (!terrainDTO) {
          console.error("‚ùå Erreur : TerrainDTO est null apr√®s remplacement !");
          alert("‚ùå Erreur lors du remplacement !");
          return;
        }
        console.log('‚úÖ Remplacement effectu√© avec succ√®s.', terrainDTO);
  
        this.terrain = terrainDTO;
  
        // ‚úÖ Mettre `aJoue = true` pour le joueur entrant
        this.terrain.titulaires.forEach(joueur => {
          if (joueur.jid === this.joueurEntrant!.jid) {
            joueur.aJoue = true;
          }
        });
  
        this.actualiserTempsDeJeu(minuteEntree);
        this.actualiserListeJoueurs();
        this.cdr.detectChanges();
        alert("‚úÖ Remplacement valid√© !");
      },
      error: (err) => {
        console.error('‚ùå Erreur lors du remplacement:', err);
        alert("‚ùå Erreur lors du remplacement !");
      }
    });
  }
  
  











  actualiserTempsDeJeu(minuteEntree: number): void {
    if (!this.joueurSortant || !this.joueurEntrant) return;
  
    // ‚úÖ Ajustement du temps de jeu
    const minutesSortant = this.terrain.terrainJoueurs[this.joueurSortant.poste]?.minutesJouees || 90;
    const minutesJoueesRemplacant = minutesSortant - (minuteEntree * 90);
  
    // ‚úÖ Mettre √† jour les valeurs
    this.terrain.terrainJoueurs[this.joueurSortant.poste].minutesJouees = minuteEntree * 90;
    this.terrain.terrainJoueurs[this.joueurEntrant.poste].minutesJouees = minutesJoueesRemplacant;
  
    console.log(`‚è≥ Mise √† jour des minutes : ${this.joueurSortant.nom} ‚Üí ${minuteEntree * 90} min, ${this.joueurEntrant.nom} ‚Üí ${minutesJoueesRemplacant} min`);
  }
  
  





  actualiserListeJoueurs(): void {
    if (!this.terrain) {
      console.error("‚ùå Erreur : Terrain non initialis√©.");
      return;
    }
  
    if (this.joueurSortant && this.joueurEntrant) {
      console.log("üîÑ Mise √† jour des listes apr√®s remplacement :", this.joueurSortant.nom, "sort et", this.joueurEntrant.nom, "entre");
  
      // ‚úÖ Supprime le joueur sortant des titulaires et l'ajoute aux rempla√ßants
      this.terrain.titulaires = this.terrain.titulaires.filter(j => j.jid !== this.joueurSortant!.jid);
      this.terrain.remplacants.push(this.joueurSortant!);
  
      // ‚úÖ Supprime le joueur entrant des rempla√ßants et l'ajoute aux titulaires
      this.terrain.remplacants = this.terrain.remplacants.filter(j => j.jid !== this.joueurEntrant!.jid);
      this.terrain.titulaires.push(this.joueurEntrant!);
  
      // ‚úÖ Mise √† jour du terrain en rempla√ßant le joueur sortant par le rempla√ßant
      Object.keys(this.terrain.terrainJoueurs).forEach(poste => {
        if (this.terrain.terrainJoueurs[poste]?.jid === this.joueurSortant!.jid) {
          this.terrain.terrainJoueurs[poste] = this.joueurEntrant!;
        }
      });
  
      // ‚úÖ Mettre `aJoue = true` pour le joueur entrant
      this.joueurEntrant!.aJoue = true;
  
      console.log("üîÑ Mise √† jour du terrain apr√®s remplacement:", this.terrain.terrainJoueurs);
  
      // ‚úÖ R√©initialisation des s√©lections
      this.joueurSortant = null;
      this.joueurEntrant = null;
      this.minuteRemplacement = null;
    }
  }
  





  ouvrirSelectionRemplacant(): void {
    const dialogRef = this.dialog.open(JoueurSelectionDialogComponent, {
      data: { joueurs: this.terrain.remplacants },
      width: '400px'
    });
  
    dialogRef.afterClosed().subscribe((joueurSelectionne: FeuilleDeMatchDTO) => {
      if (joueurSelectionne) {
        console.log(`üîÑ Joueur rempla√ßant s√©lectionn√© : ${joueurSelectionne.nom}`);
        this.joueurEntrant = joueurSelectionne;
      }
    });
  }
  
}
